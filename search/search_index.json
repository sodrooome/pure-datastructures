{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pure-datastructures \u00b6 A Collection of data structures wrapped as package written in python, not dependent on any other libraries or built-in function. List of Data Structures \u00b6 Stack Stack with Linked List Queue List List with Ordered List Installation \u00b6 This package only work in python 3.6 or higher, you can install it with : pip3 install pure-datastructures Test \u00b6 Using unittest for test the data structures, for running all test : python3 -m unittest tests For running specific test (example you want test Stack) : python3 -m unittest tests.test_stack Ensuring version \u00b6 To ensure the package is installed and checking current version, try to import using python in command line, and prompt an import ds in command-line for checking whether the package is successfully installed or not, to check version for now it can only be done using pip freeze or pip list .","title":"Pure-datastructures"},{"location":"#pure-datastructures","text":"A Collection of data structures wrapped as package written in python, not dependent on any other libraries or built-in function.","title":"Pure-datastructures"},{"location":"#list_of_data_structures","text":"Stack Stack with Linked List Queue List List with Ordered List","title":"List of Data Structures"},{"location":"#installation","text":"This package only work in python 3.6 or higher, you can install it with : pip3 install pure-datastructures","title":"Installation"},{"location":"#test","text":"Using unittest for test the data structures, for running all test : python3 -m unittest tests For running specific test (example you want test Stack) : python3 -m unittest tests.test_stack","title":"Test"},{"location":"#ensuring_version","text":"To ensure the package is installed and checking current version, try to import using python in command line, and prompt an import ds in command-line for checking whether the package is successfully installed or not, to check version for now it can only be done using pip freeze or pip list .","title":"Ensuring version"},{"location":"contribute/","text":"How to contribute \u00b6 When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method to the owners or maintainers of this repository before making a change. It is recommended to create a separate branch and propose a change via merge request. Here are some ways you can contribute: by reporting bugs and issues by suggesting new features by refactoring code by writing or editing documentation by writing code (fix typos, add comments, fix code style) by closing issues by reviewing patches by testing the API No contribution is too small, any kind of contribution will be highly appreciated.","title":"Contribution"},{"location":"contribute/#how_to_contribute","text":"When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method to the owners or maintainers of this repository before making a change. It is recommended to create a separate branch and propose a change via merge request. Here are some ways you can contribute: by reporting bugs and issues by suggesting new features by refactoring code by writing or editing documentation by writing code (fix typos, add comments, fix code style) by closing issues by reviewing patches by testing the API No contribution is too small, any kind of contribution will be highly appreciated.","title":"How to contribute"},{"location":"development/","text":"Development \u00b6 Pure-datastructures is under active being developed. There's a some sort of basic data structures which hasn't been published yet. Pure-datastructures repository is available through github repos either for ds repo or docs repo, you can check it out in here . Currently has a several issue for developing data structures including : Stack \u00b6 Ordered Stack Queue \u00b6 Priority Queue","title":"Development"},{"location":"development/#development","text":"Pure-datastructures is under active being developed. There's a some sort of basic data structures which hasn't been published yet. Pure-datastructures repository is available through github repos either for ds repo or docs repo, you can check it out in here . Currently has a several issue for developing data structures including :","title":"Development"},{"location":"development/#stack","text":"Ordered Stack","title":"Stack"},{"location":"development/#queue","text":"Priority Queue","title":"Queue"},{"location":"drawbacks/","text":"Drawbacks \u00b6 Since this package is alpha/beta development, currently there's a major drawback if using several data structures API. Performance is not measured \u00b6 The biggest changing are performance is not coverage enough for production release. Since, this package is currently on alpha/beta development, any performance is not measured enough (or you can benchmark yourself using cProfile ). Even though, i'm pretty confident this scenarios are using Big-O-Notation references (has a average - worst scenario for time complexity). Limited input size \u00b6 Limiting size only, you can change the default data-types, but you can't initialize length of some arrays or any value, in your existing code. I have set a maxsize for each data structures params, Limit size is 10. Non-recursive for searching \u00b6 Being developed, the idea of \u200b\u200busing recursive on every data structure allows to store all values \u200b\u200bin a function and not delete those values \u200b\u200bif we do a pop . Handling exception \u00b6 Unfortunately, for throwing exceptions are not yet fully available (and still being developed). If you have any error if perform or when executing the code, the default error that appears is the default exception from python. Although there are some events that bringing up an raise IndexError if the stack is empty.","title":"Drawbacks"},{"location":"drawbacks/#drawbacks","text":"Since this package is alpha/beta development, currently there's a major drawback if using several data structures API.","title":"Drawbacks"},{"location":"drawbacks/#performance_is_not_measured","text":"The biggest changing are performance is not coverage enough for production release. Since, this package is currently on alpha/beta development, any performance is not measured enough (or you can benchmark yourself using cProfile ). Even though, i'm pretty confident this scenarios are using Big-O-Notation references (has a average - worst scenario for time complexity).","title":"Performance is not measured"},{"location":"drawbacks/#limited_input_size","text":"Limiting size only, you can change the default data-types, but you can't initialize length of some arrays or any value, in your existing code. I have set a maxsize for each data structures params, Limit size is 10.","title":"Limited input size"},{"location":"drawbacks/#non-recursive_for_searching","text":"Being developed, the idea of \u200b\u200busing recursive on every data structure allows to store all values \u200b\u200bin a function and not delete those values \u200b\u200bif we do a pop .","title":"Non-recursive for searching"},{"location":"drawbacks/#handling_exception","text":"Unfortunately, for throwing exceptions are not yet fully available (and still being developed). If you have any error if perform or when executing the code, the default error that appears is the default exception from python. Although there are some events that bringing up an raise IndexError if the stack is empty.","title":"Handling exception"},{"location":"purposes/","text":"Why this package? Are you mad or something? \u00b6 Actually, in real-world scenario, this package is seem meaningless. For example if you use it in web programming, concepts such as Stack, List, or Queue are bundled when you initialize queries in the database. All you need to do is how the query works and modify it as needed. The purpose of making this package is, basically only for documentation in implementing data structures (or you can tell it, learning purposes only or for education), then gradually changes to make it a package where this package will be modular and dependency-injection to other programs, as long as it's still in python environment. So what's the difference between this package with other packages or built-in functions? This package comes to minimal and clean implementation, thus, we do not use the help of built-in functions such as pop , insert , or other methods or decorators, and also modules (python comes it handy with data structures module) but from the beginning this package will be written in pure python code, instead using pop or something like that, we want to write an abstract base class then inherit it into some function, or make it a decorator (although i'm not really sure for implementing abstract classes, do you need a module or just make it yourself). The biggest difference in this package i think is that, in the meantime, this package can be override and anyone who uses can customize it for themselves while learning and understanding how data structures can work from scratch, and thats why this documentation exists.","title":"Purposes"},{"location":"purposes/#why_this_package_are_you_mad_or_something","text":"Actually, in real-world scenario, this package is seem meaningless. For example if you use it in web programming, concepts such as Stack, List, or Queue are bundled when you initialize queries in the database. All you need to do is how the query works and modify it as needed. The purpose of making this package is, basically only for documentation in implementing data structures (or you can tell it, learning purposes only or for education), then gradually changes to make it a package where this package will be modular and dependency-injection to other programs, as long as it's still in python environment. So what's the difference between this package with other packages or built-in functions? This package comes to minimal and clean implementation, thus, we do not use the help of built-in functions such as pop , insert , or other methods or decorators, and also modules (python comes it handy with data structures module) but from the beginning this package will be written in pure python code, instead using pop or something like that, we want to write an abstract base class then inherit it into some function, or make it a decorator (although i'm not really sure for implementing abstract classes, do you need a module or just make it yourself). The biggest difference in this package i think is that, in the meantime, this package can be override and anyone who uses can customize it for themselves while learning and understanding how data structures can work from scratch, and thats why this documentation exists.","title":"Why this package? Are you mad or something?"},{"location":"references/","text":"API References \u00b6 All about concise API references manual for pure-datastructures , with the detail about classes, function, return types, arguments and throwing exception. procedure_search_obj(**kwargs) \u00b6 Search any value / elements through List. return False if there's a value otherwise return True . Throwing missing {} required positional arguments if not set the value. procedure_push(**kwargs) \u00b6 Set a value through List and Queue , like a basic insertion or appending a value. For OrderedList() , new value didn't stored in temporary variables, likewise, for UnorderedList() new value would be stored in temporary variables (since UnorderedList() is using 0(n) for append a value). procedure_pop() \u00b6 Same function like procedure_push() , the different this will raise an IndexError if stack is empty or has no value. Only work in Stack references. procedure_expand_size() \u00b6 Expanding or double length of array (formula: array + None * size of array) . Work in all data structures references. Automatically return None if an array doesn't have a value. procedure_peek() \u00b6 Check the top-most of any elements in array. procedure_enqueue(**kwargs) \u00b6 Push new object or value to queue. procedure_dequeue() \u00b6 Remove first object or value from queue. Raise an IndexError if you have not set a value before popped out. As a for concern, dequeue process in basic Queue and CircularQueue is different. is_empty() \u00b6 Check whether an array does have a value or not. In Stack and Queue case, will return False if stack/queue is empty and return True if not empty. For List , will not return any value except None . is_full() \u00b6 Check whether an array does have a value or not. Only available in Stack and Queue , throwing exceptions work out same as like is_empty() . is_balanced() \u00b6 Check if an array does have a same balanced through inputted value, available in Stack and Queue only. Inputted value only works with parenthesis like. DsIndexError() \u00b6 Throwing exception, one of the basic and common error in this package. This will raise if inputted value is attempt to access the outside that index of list. Error message : Stack / List / Queue is empty, set a value first. DsPeekIndexError() \u00b6 Throwing exception, the difference with DsIndexError() , it will raise if procedure_peek() process didn't find any value from that index of list. Error message : Stack / List / Queue is empty, you either must be popped or not set a value. DsValueError() \u00b6 Throwing exception, that indicates the data-type or value is not correct. Error message : Value error, either your argument or inputted value is not correct.","title":"References"},{"location":"references/#api_references","text":"All about concise API references manual for pure-datastructures , with the detail about classes, function, return types, arguments and throwing exception.","title":"API References"},{"location":"references/#procedure_search_objkwargs","text":"Search any value / elements through List. return False if there's a value otherwise return True . Throwing missing {} required positional arguments if not set the value.","title":"procedure_search_obj(**kwargs)"},{"location":"references/#procedure_pushkwargs","text":"Set a value through List and Queue , like a basic insertion or appending a value. For OrderedList() , new value didn't stored in temporary variables, likewise, for UnorderedList() new value would be stored in temporary variables (since UnorderedList() is using 0(n) for append a value).","title":"procedure_push(**kwargs)"},{"location":"references/#procedure_pop","text":"Same function like procedure_push() , the different this will raise an IndexError if stack is empty or has no value. Only work in Stack references.","title":"procedure_pop()"},{"location":"references/#procedure_expand_size","text":"Expanding or double length of array (formula: array + None * size of array) . Work in all data structures references. Automatically return None if an array doesn't have a value.","title":"procedure_expand_size()"},{"location":"references/#procedure_peek","text":"Check the top-most of any elements in array.","title":"procedure_peek()"},{"location":"references/#procedure_enqueuekwargs","text":"Push new object or value to queue.","title":"procedure_enqueue(**kwargs)"},{"location":"references/#procedure_dequeue","text":"Remove first object or value from queue. Raise an IndexError if you have not set a value before popped out. As a for concern, dequeue process in basic Queue and CircularQueue is different.","title":"procedure_dequeue()"},{"location":"references/#is_empty","text":"Check whether an array does have a value or not. In Stack and Queue case, will return False if stack/queue is empty and return True if not empty. For List , will not return any value except None .","title":"is_empty()"},{"location":"references/#is_full","text":"Check whether an array does have a value or not. Only available in Stack and Queue , throwing exceptions work out same as like is_empty() .","title":"is_full()"},{"location":"references/#is_balanced","text":"Check if an array does have a same balanced through inputted value, available in Stack and Queue only. Inputted value only works with parenthesis like.","title":"is_balanced()"},{"location":"references/#dsindexerror","text":"Throwing exception, one of the basic and common error in this package. This will raise if inputted value is attempt to access the outside that index of list. Error message : Stack / List / Queue is empty, set a value first.","title":"DsIndexError()"},{"location":"references/#dspeekindexerror","text":"Throwing exception, the difference with DsIndexError() , it will raise if procedure_peek() process didn't find any value from that index of list. Error message : Stack / List / Queue is empty, you either must be popped or not set a value.","title":"DsPeekIndexError()"},{"location":"references/#dsvalueerror","text":"Throwing exception, that indicates the data-type or value is not correct. Error message : Value error, either your argument or inputted value is not correct.","title":"DsValueError()"},{"location":"releases/","text":"Release history \u00b6 Using semantic versioning and based on PEP 440 (version identification and dependency specification). All the release history (binary / numbers only) can be found in PyPi changelog Changelog \u00b6 Pure-datastructures 0.2.0 (2021-29--05) \u00b6 Highlights : Remove BalancedParentheses method Better adjustment for typing annotations and parameter declaration Simplification several methods in List method Issues : Inserting new object in DoubleLinkedList raise an exception even though already filled the value Index out of range issue in Stack assignment All built-in APIs for PriorityQueue not working at all Pure-datastructures 0.1.4 (2020-25-05) \u00b6 Highlights : Adding benchmark decorators for measure code performance Adding DoubleLinkedList Adding custom exception for List Fixed inserting new object in Stack , Queue , CircularQueue and List Issues : Inserting new object in PriorityQueue not working Inserting new object in OrderedStack will return empty list, this shouldn't be have an object or list Pure-datastructures 0.1.3 (2020-14-05) \u00b6 Highlights : Adding custom exception for Queue and Stack Pure-datastructures 0.1.2 (2020-10-05) \u00b6 Highlights : Dropped support for python 2.7 or below Adding is_balanced() in Stack and Queue Providing delete node on List using procedure_delete_node() Pure-datastructures 0.1.1 (2020-07-05) \u00b6 Highlights : Fixed is_empty() only return False Fixed unittest not discover of all test Adding is_full() in Stack and Queue Adding CircularQueue() Adding IndexError in Queue Depth coverage about throwing exceptions in Queue and Stack Pure-datastructures 0.1.0 (2020-05-05) \u00b6 Highlights : Fixed iteration in LinkedList Reorganize all data structures Adding UnorderedList size() functions are changing into expand_size() Pure-datastructures 0.0.8 (2020-04-05) \u00b6 Highlights : Adding search_obj() for List . Adding basic queueing (perform enqueue , dequeue and is_empty ) Pure-datastructures 0.0.5 (2020-04-05) \u00b6 Highlights : Remove mock test in every references Pure-datastructures 0.0.1 (2020-04-05) \u00b6 Pre-release for pure-datastructures","title":"Release Note"},{"location":"releases/#release_history","text":"Using semantic versioning and based on PEP 440 (version identification and dependency specification). All the release history (binary / numbers only) can be found in PyPi changelog","title":"Release history"},{"location":"releases/#changelog","text":"","title":"Changelog"},{"location":"releases/#pure-datastructures_020_2021-29--05","text":"Highlights : Remove BalancedParentheses method Better adjustment for typing annotations and parameter declaration Simplification several methods in List method Issues : Inserting new object in DoubleLinkedList raise an exception even though already filled the value Index out of range issue in Stack assignment All built-in APIs for PriorityQueue not working at all","title":"Pure-datastructures 0.2.0 (2021-29--05)"},{"location":"releases/#pure-datastructures_014_2020-25-05","text":"Highlights : Adding benchmark decorators for measure code performance Adding DoubleLinkedList Adding custom exception for List Fixed inserting new object in Stack , Queue , CircularQueue and List Issues : Inserting new object in PriorityQueue not working Inserting new object in OrderedStack will return empty list, this shouldn't be have an object or list","title":"Pure-datastructures 0.1.4 (2020-25-05)"},{"location":"releases/#pure-datastructures_013_2020-14-05","text":"Highlights : Adding custom exception for Queue and Stack","title":"Pure-datastructures 0.1.3 (2020-14-05)"},{"location":"releases/#pure-datastructures_012_2020-10-05","text":"Highlights : Dropped support for python 2.7 or below Adding is_balanced() in Stack and Queue Providing delete node on List using procedure_delete_node()","title":"Pure-datastructures 0.1.2 (2020-10-05)"},{"location":"releases/#pure-datastructures_011_2020-07-05","text":"Highlights : Fixed is_empty() only return False Fixed unittest not discover of all test Adding is_full() in Stack and Queue Adding CircularQueue() Adding IndexError in Queue Depth coverage about throwing exceptions in Queue and Stack","title":"Pure-datastructures 0.1.1 (2020-07-05)"},{"location":"releases/#pure-datastructures_010_2020-05-05","text":"Highlights : Fixed iteration in LinkedList Reorganize all data structures Adding UnorderedList size() functions are changing into expand_size()","title":"Pure-datastructures 0.1.0 (2020-05-05)"},{"location":"releases/#pure-datastructures_008_2020-04-05","text":"Highlights : Adding search_obj() for List . Adding basic queueing (perform enqueue , dequeue and is_empty )","title":"Pure-datastructures 0.0.8 (2020-04-05)"},{"location":"releases/#pure-datastructures_005_2020-04-05","text":"Highlights : Remove mock test in every references","title":"Pure-datastructures 0.0.5 (2020-04-05)"},{"location":"releases/#pure-datastructures_001_2020-04-05","text":"Pre-release for pure-datastructures","title":"Pure-datastructures 0.0.1 (2020-04-05)"},{"location":"usage/","text":"Quick sample \u00b6 A quick introduction using pure-datastructures . Using OrderedList() references and integers input-type : import ds scenario = ds.OrderedList() # basic insertion scenario.procedure_push(70) scenario.procedure_push(13) scenario.procedure_push(-3) # calculate size of array with `size()` # return length of array print(scenario.procedure_expand_size()) # searching value through array with `search_obj()` # return False if value is not founds print(scenario.procedure_search_obj(5)) Another example using basic Stack() , and string as input-type : import ds scenario = ds.Stack() # basic insertion scenario.procedure_push('json') # the function same as the above # return length of array print(scenario.procedure_expand_size()) # check the top-most element of stack # return value of element print(scenario.procedure_peek()) Or you can iterate Stack , to push a new value using for-loop. This is also applies to all data structures : import ds scenario = ds.Stack() # iterate push new value to stack for x in range(1,4): scenario.procedure_push(x) print(scenario.procedure_peek()) An example using Queue : import ds scenario = ds.Queue() # check an array # return None if has no value print(scenario.is_empty()) # push new value to queue scenario.procedure_enqueue(3) An example using Doublelinkedlist : import ds scenario = ds.DoubleLinkedList() # push new object at the beginning list scenario.procedure_insert_list(1) # push new object at the end of list scenario.procedure_insert_end(5) print(scenario.procedure_search_obj(-7)) # delete object at the beginning of list print(scenario.procedure_delete_obj()) For benchmarking code, you can override benchmark decorators in your program : import ds from decorators import benchmark # add new line scenario = ds.Stack() # benchmarking only be done # if using function # add decorators here @benchmark def test_foo(): for x in range(1,10): scenario.procedure_push(x) # return the result # of function that we call if __name__ == '__main__': test_foo() For more complete example will be written very soon.","title":"Usage"},{"location":"usage/#quick_sample","text":"A quick introduction using pure-datastructures . Using OrderedList() references and integers input-type : import ds scenario = ds.OrderedList() # basic insertion scenario.procedure_push(70) scenario.procedure_push(13) scenario.procedure_push(-3) # calculate size of array with `size()` # return length of array print(scenario.procedure_expand_size()) # searching value through array with `search_obj()` # return False if value is not founds print(scenario.procedure_search_obj(5)) Another example using basic Stack() , and string as input-type : import ds scenario = ds.Stack() # basic insertion scenario.procedure_push('json') # the function same as the above # return length of array print(scenario.procedure_expand_size()) # check the top-most element of stack # return value of element print(scenario.procedure_peek()) Or you can iterate Stack , to push a new value using for-loop. This is also applies to all data structures : import ds scenario = ds.Stack() # iterate push new value to stack for x in range(1,4): scenario.procedure_push(x) print(scenario.procedure_peek()) An example using Queue : import ds scenario = ds.Queue() # check an array # return None if has no value print(scenario.is_empty()) # push new value to queue scenario.procedure_enqueue(3) An example using Doublelinkedlist : import ds scenario = ds.DoubleLinkedList() # push new object at the beginning list scenario.procedure_insert_list(1) # push new object at the end of list scenario.procedure_insert_end(5) print(scenario.procedure_search_obj(-7)) # delete object at the beginning of list print(scenario.procedure_delete_obj()) For benchmarking code, you can override benchmark decorators in your program : import ds from decorators import benchmark # add new line scenario = ds.Stack() # benchmarking only be done # if using function # add decorators here @benchmark def test_foo(): for x in range(1,10): scenario.procedure_push(x) # return the result # of function that we call if __name__ == '__main__': test_foo() For more complete example will be written very soon.","title":"Quick sample"}]}